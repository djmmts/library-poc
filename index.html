<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Cardano NFT Book Rental DApp</title>
</head>
<body>
	<h1>Rent a Book NFT on Cardano Preprod</h1>
	<p>Connect your wallet on Preprod network.</p>
	
	<button id="connectWallet">Connect Wallet</button>
	<p id="walletStatus"></p>

	<h2>List Rental Offer</h2>
	<label for="daily_fee">Daily Fee (lovelace):</label>
	<input type="number" id="daily_fee" min="1000000" value="1000000">
	
	<label for="min_days">Min Days:</label>
	<input type="number" id="min_days" min="1" value="1">
	
	<label for="max_days">Max Days:</label>
	<input type="number" id="max_days" min="1" value="30">
	
	<label for="auto_relist">Auto Relist:</label>
	<input type="checkbox" id="auto_relist" checked>
	
	<label for="nft_picker">Select NFT to List:</label>
	<select id="nft_picker">
		<option value="">--Select an NFT--</option>
	</select>
	
	<button id="listButton" disabled>List Rental</button>
	<p id="listStatus"></p>

	<h2>Rent Book</h2>
	<label for="rental_picker">Select Rental to Rent:</label>
	<select id="rental_picker">
		<option value="">--Select a Rental--</option>
	</select>
	
	<label for="days">Days to Rent:</label>
	<input type="number" id="days" min="1" value="1">
	
	<button id="rentButton" disabled>Rent Book</button>
	<p id="txStatus"></p>

	<script type="module">
		// Import Cardano JS SDK modules
		import { 
			Cardano,
			TxBuilder,
			PlutusData,
			PlutusScript
		} from 'https://cdn.jsdelivr.net/npm/@cardano-sdk/core@0.35.0/+esm';
		
		import {
			BlockfrostCardanoNetworkInfoProvider,
			BlockfrostUtxoProvider
		} from 'https://cdn.jsdelivr.net/npm/@cardano-sdk/blockfrost@0.35.0/+esm';

		// Script configuration
		const scriptCBOR = 'YOUR_SCRIPT_CBOR_HERE';
		const scriptAddress = 'addr_test1wzmxf4q03j25mua0wl7mh54adwnd5c97sh9fn92jzep47dsyjc380';
		const blockfrostProjectId = 'preprod5njBajXTux1u0d7vJCH9kOgsvPCDIe6W';

		let wallet;
		let walletApi;
		let walletAddress;
		let txBuilder;

		// Initialize providers
		const networkInfoProvider = new BlockfrostCardanoNetworkInfoProvider(
			{ projectId: blockfrostProjectId },
			{ baseUrl: 'https://cardano-preprod.blockfrost.io/api/v0' }
		);

		const utxoProvider = new BlockfrostUtxoProvider(
			{ projectId: blockfrostProjectId },
			{ baseUrl: 'https://cardano-preprod.blockfrost.io/api/v0' }
		);

		function hexToString(hex) {
			try {
				let str = '';
				for (let i = 0; i < hex.length; i += 2) {
					str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
				}
				return str;
			} catch (e) {
				return hex;
			}
		}

		// Populate NFT picker
		async function populateNftPicker() {
			const nftPicker = document.getElementById('nft_picker');
			nftPicker.innerHTML = '<option value="">--Select an NFT--</option>';
			
			try {
				const utxos = await walletApi.getUtxos();
				const assets = new Map();
				
				for (const utxoHex of utxos) {
					// Parse UTXO CBOR to extract assets
					// This is simplified - in production use proper CBOR parsing
					console.log('UTXO:', utxoHex);
				}
				
				// For now, add mock data
				const option = document.createElement('option');
				option.value = 'mock_policy|mock_name';
				option.textContent = 'Mock NFT';
				nftPicker.appendChild(option);
			} catch (e) {
				console.error('Error populating NFTs:', e);
			}
		}

		// Populate rental picker
		async function populateRentalPicker() {
			try {
				const rentalPicker = document.getElementById('rental_picker');
				rentalPicker.innerHTML = '<option value="">--Select a Rental--</option>';
				
				// Query UTXOs at script address
				const scriptUtxos = await utxoProvider.utxoByAddresses([scriptAddress]);
				console.log(`Found ${scriptUtxos.length} UTxOs at script address`);
				
				for (const utxo of scriptUtxos) {
					// Check if has NFT and datum
					if (utxo.datum) {
						const option = document.createElement('option');
						option.value = `${utxo.txId}#${utxo.index}`;
						option.textContent = `NFT Available for rent`;
						option.dataset.utxo = JSON.stringify(utxo);
						rentalPicker.appendChild(option);
					}
				}
			} catch (e) {
				console.error('Error in populateRentalPicker:', e);
			}
		}

		// Connect wallet
		document.getElementById('connectWallet').addEventListener('click', async () => {
			try {
				// Check for Eternl
				if (!window.cardano || !window.cardano.eternl) {
					throw new Error('Eternl wallet not found');
				}

				// Enable wallet
				walletApi = await window.cardano.eternl.enable();
				
				// Check network
				const networkId = await walletApi.getNetworkId();
				if (networkId !== 0) {
					document.getElementById('walletStatus').textContent = 'Please switch to Preprod network!';
					return;
				}

				// Get change address
				const addressHex = await walletApi.getChangeAddress();
				walletAddress = Cardano.Address.fromHex(addressHex);
				
				// Initialize transaction builder
				const protocolParameters = await networkInfoProvider.protocolParameters();
				txBuilder = new TxBuilder(protocolParameters);

				document.getElementById('walletStatus').textContent = 'Wallet connected!';
				document.getElementById('listButton').disabled = false;
				document.getElementById('rentButton').disabled = false;

				await populateNftPicker();
				await populateRentalPicker();
			} catch (error) {
				console.error('Wallet connection error:', error);
				document.getElementById('walletStatus').textContent = 'Failed to connect: ' + error.message;
			}
		});

		// List NFT
		document.getElementById('listButton').addEventListener('click', async () => {
			try {
				console.log('=== LIST BUTTON CLICKED ===');
				const daily_fee = parseInt(document.getElementById('daily_fee').value);
				const min_days = parseInt(document.getElementById('min_days').value);
				const max_days = parseInt(document.getElementById('max_days').value);
				const auto_relist = document.getElementById('auto_relist').checked;
				const selectedNft = document.getElementById('nft_picker').value;

				if (!selectedNft) throw new Error('Please select an NFT');

				const [nft_policy, nft_name] = selectedNft.split('|');
				
				// Get payment key hash from address
				const paymentKeyHash = walletAddress.getPaymentCredential()?.hash;
				if (!paymentKeyHash) throw new Error('Could not get payment key hash');

				// Build datum using PlutusData
				const datum = PlutusData.fromCore({
					constructor: 0n,
					fields: [
						PlutusData.fromCore(paymentKeyHash),
						PlutusData.fromCore(BigInt(daily_fee)),
						PlutusData.fromCore(BigInt(min_days)),
						PlutusData.fromCore(BigInt(max_days)),
						PlutusData.fromCore({ constructor: auto_relist ? 1n : 0n, fields: [] }),
						PlutusData.fromCore({ constructor: 1n, fields: [] }), // None
						PlutusData.fromCore({ constructor: 1n, fields: [] }), // None
						PlutusData.fromCore(nft_policy),
						PlutusData.fromCore(nft_name)
					]
				});

				// Build transaction
				// Note: TxBuilder API may vary - check latest docs
				const tx = txBuilder
					.addOutput({
						address: scriptAddress,
						value: {
							coins: 2000000n,
							assets: new Map([[`${nft_policy}${nft_name}`, 1n]])
						},
						datum
					})
					.build();

				// Sign and submit
				const witnessSet = await walletApi.signTx(tx.toCbor(), true);
				const signedTx = tx.withWitnessSet(witnessSet);
				const txHash = await walletApi.submitTx(signedTx.toCbor());

				document.getElementById('listStatus').textContent = `Listed! Tx: ${txHash}`;
				setTimeout(populateRentalPicker, 3000);
			} catch (error) {
				console.error('List error:', error);
				document.getElementById('listStatus').textContent = `Error: ${error.message}`;
			}
		});

		// Rent NFT
		document.getElementById('rentButton').addEventListener('click', async () => {
			console.log('=== RENT BUTTON CLICKED ===');
			try {
				const days = parseInt(document.getElementById('days').value);
				const selectedRental = document.getElementById('rental_picker').value;
				
				if (!selectedRental || days <= 0) throw new Error('Invalid selection');

				// Get selected UTXO
				const selectedOption = document.querySelector(`#rental_picker option[value="${selectedRental}"]`);
				const utxo = JSON.parse(selectedOption.dataset.utxo);
				
				// Build redeemer
				const redeemer = PlutusData.fromCore({
					constructor: 0n, // Rent variant
					fields: [PlutusData.fromCore(BigInt(days))]
				});

				// Get current slot for validity interval
				const currentSlot = await networkInfoProvider.currentSlot();
				
				// Build transaction with validity interval
				const tx = txBuilder
					.setValidityInterval({
						invalidBefore: currentSlot,
						invalidHereafter: currentSlot + 600n
					})
					.addInput({
						utxo,
						script: {
							type: 'PlutusV2',
							cbor: scriptCBOR,
							datum: utxo.datum,
							redeemer
						}
					})
					// Add outputs, change, etc.
					.build();

				// Sign and submit
				const witnessSet = await walletApi.signTx(tx.toCbor(), true);
				const signedTx = tx.withWitnessSet(witnessSet);
				const txHash = await walletApi.submitTx(signedTx.toCbor());

				document.getElementById('txStatus').textContent = `Rented! Tx: ${txHash}`;
				setTimeout(populateRentalPicker, 3000);
			} catch (error) {
				console.error('=== RENT ERROR ===');
				console.error('Full error:', error);
				document.getElementById('txStatus').textContent = `Error: ${error.message}`;
			}
		});
	</script>
</body>
</html>