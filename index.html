<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Cardano NFT Book Rental DApp</title>
</head>
<body>
	<h1>Rent a Book NFT on Cardano Preprod</h1>
	<p>Connect your wallet on Preprod network.</p>
	
	<button id="connectWallet">Connect Wallet</button>
	<p id="walletStatus"></p>

	<h2>List Rental Offer</h2>
	<label for="daily_fee">Daily Fee (lovelace):</label>
	<input type="number" id="daily_fee" min="1000000" value="1000000">
	
	<label for="min_days">Min Days:</label>
	<input type="number" id="min_days" min="1" value="1">
	
	<label for="max_days">Max Days:</label>
	<input type="number" id="max_days" min="1" value="30">
	
	<label for="auto_relist">Auto Relist:</label>
	<input type="checkbox" id="auto_relist" checked>
	
	<label for="nft_picker">Select NFT to List:</label>
	<select id="nft_picker">
		<option value="">--Select an NFT--</option>
	</select>
	
	<button id="listButton" disabled>List Rental</button>
	<p id="listStatus"></p>

	<h2>Rent Book</h2>
	<label for="rental_picker">Select Rental to Rent:</label>
	<select id="rental_picker">
		<option value="">--Select a Rental--</option>
	</select>
	
	<label for="days">Days to Rent:</label>
	<input type="number" id="days" min="1" value="1">
	
	<button id="rentButton" disabled>Rent Book</button>
	<p id="txStatus"></p>

	<!-- Following Mesh docs, use ESM module -->
	<script type="module">
		import { BlockfrostProvider, MeshWallet, Transaction, resolvePaymentKeyHash, conStr0, conStr1 } from 'https://cdn.jsdelivr.net/npm/@meshsdk/core@1.6.1/+esm';

		// Script CBOR - add your script here
		const scriptCBOR = 'YOUR_SCRIPT_CBOR_HERE';
		const scriptAddress = 'addr_test1wzmxf4q03j25mua0wl7mh54adwnd5c97sh9fn92jzep47dsyjc380';

		let wallet;
		let walletAddress;

		// Initialize Blockfrost provider as per Mesh docs
		const blockfrostProvider = new BlockfrostProvider('preprod5njBajXTux1u0d7vJCH9kOgsvPCDIe6W');

		function hexToString(hex) {
			try {
				let str = '';
				for (let i = 0; i < hex.length; i += 2) {
					str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
				}
				return str;
			} catch (e) {
				return hex;
			}
		}

		async function populateNftPicker() {
			const nftPicker = document.getElementById('nft_picker');
			nftPicker.innerHTML = '<option value="">--Select an NFT--</option>';
			
			try {
				const assets = await wallet.getAssets();
				
				assets.forEach(asset => {
					if (asset.quantity === "1") {
						const policyId = asset.unit.slice(0, 56);
						const assetName = asset.unit.slice(56);
						const name = hexToString(assetName);
						
						const option = document.createElement('option');
						option.value = `${policyId}|${assetName}`;
						option.textContent = `${name} (${policyId.slice(0, 10)}...)`;
						nftPicker.appendChild(option);
					}
				});
			} catch (e) {
				console.error('Error populating NFTs:', e);
			}
		}

		async function populateRentalPicker() {
			try {
				const rentalPicker = document.getElementById('rental_picker');
				rentalPicker.innerHTML = '<option value="">--Select a Rental--</option>';
				
				const utxos = await blockfrostProvider.fetchAddressUTxOs(scriptAddress);
				console.log(`Found ${utxos.length} UTxOs at script address`);
				
				for (const utxo of utxos) {
					const hasNft = utxo.output.amount.some(asset => asset.unit !== 'lovelace');
					if (hasNft && utxo.output.plutusData) {
						try {
							const nftAsset = utxo.output.amount.find(asset => asset.unit !== 'lovelace');
							const nftName = hexToString(nftAsset.unit.slice(56));
							
							const option = document.createElement('option');
							option.value = `${utxo.input.txHash}#${utxo.input.outputIndex}`;
							option.textContent = `NFT: ${nftName} | Available for rent`;
							option.dataset.utxo = JSON.stringify(utxo);
							rentalPicker.appendChild(option);
						} catch (e) {
							console.error('Error parsing rental:', e);
						}
					}
				}
			} catch (e) {
				console.error('Error in populateRentalPicker:', e);
			}
		}

		// Connect wallet button
		document.getElementById('connectWallet').addEventListener('click', async () => {
			try {
				// Get available wallets as per Mesh docs
				const wallets = MeshWallet.getInstalledWallets();
				console.log('Available wallets:', wallets);
				
				// Connect to Eternl
				wallet = await MeshWallet.enable('eternl');
				
				const networkId = await wallet.getNetworkId();
				if (networkId !== 0) {
					document.getElementById('walletStatus').textContent = 'Please switch to Preprod network!';
					return;
				}
				
				walletAddress = await wallet.getChangeAddress();
				document.getElementById('walletStatus').textContent = 'Wallet connected!';
				document.getElementById('listButton').disabled = false;
				document.getElementById('rentButton').disabled = false;
				
				await populateNftPicker();
				await populateRentalPicker();
			} catch (error) {
				console.error('Wallet connection error:', error);
				document.getElementById('walletStatus').textContent = 'Failed to connect wallet: ' + error.message;
			}
		});

		// List NFT button
		document.getElementById('listButton').addEventListener('click', async () => {
			try {
				console.log('=== LIST BUTTON CLICKED ===');
				const daily_fee = parseInt(document.getElementById('daily_fee').value);
				const min_days = parseInt(document.getElementById('min_days').value);
				const max_days = parseInt(document.getElementById('max_days').value);
				const auto_relist = document.getElementById('auto_relist').checked;
				const selectedNft = document.getElementById('nft_picker').value;

				if (!selectedNft) throw new Error('Please select an NFT');
				
				const [nft_policy, nft_name] = selectedNft.split('|');
				const lenderPkh = resolvePaymentKeyHash(walletAddress);

				// Build datum using Mesh data constructors
				const datum = conStr0([
					lenderPkh,
					daily_fee,
					min_days,
					max_days,
					auto_relist ? conStr1([]) : conStr0([]),
					conStr1([]), // None for renter_pkh
					conStr1([]), // None for deadline
					nft_policy,
					nft_name
				]);

				// Build transaction with Mesh Transaction builder
				const tx = new Transaction({ initiator: wallet, parameters: blockfrostProvider })
					.sendAssets(
						{
							address: scriptAddress,
							datum: { value: datum }
						},
						[{ unit: nft_policy + nft_name, quantity: '1' }]
					);

				const unsignedTx = await tx.build();
				const signedTx = await wallet.signTx(unsignedTx);
				const txHash = await wallet.submitTx(signedTx);

				document.getElementById('listStatus').textContent = `Listed! Tx: ${txHash}`;
				setTimeout(populateRentalPicker, 3000);
			} catch (error) {
				console.error('List error:', error);
				document.getElementById('listStatus').textContent = `Error: ${error.message}`;
			}
		});

		// Rent NFT button
		document.getElementById('rentButton').addEventListener('click', async () => {
			console.log('=== RENT BUTTON CLICKED ===');
			try {
				const days = parseInt(document.getElementById('days').value);
				const selectedRental = document.getElementById('rental_picker').value;
				const selectedOption = document.querySelector(`#rental_picker option[value="${selectedRental}"]`);
				
				if (!selectedRental || days <= 0) throw new Error('Invalid selection');

				const utxo = JSON.parse(selectedOption.dataset.utxo);
				const renterPkh = resolvePaymentKeyHash(walletAddress);
				
				// Calculate deadline in milliseconds
				const deadline = Date.now() + (days * 86400000);

				// For demo, using hardcoded values - in production, parse from datum
				const lenderPkh = 'b62dfb058c502b5b2519f566732774d8c55764614571334deecf0ac7';
				const lenderAddress = 'addr_test1vzmzm7c933gzkke9r86kvue8wnvv24myv9zhzv6dam8s43ca33fq3';
				const daily_fee = 1000000;
				const nftAsset = utxo.output.amount.find(a => a.unit !== 'lovelace');

				// Build updated datum
				const updatedDatum = conStr0([
					lenderPkh,
					daily_fee,
					1, // min_days
					30, // max_days
					conStr1([]), // auto_relist true
					conStr0([renterPkh]), // Some(renter)
					conStr0([deadline]), // Some(deadline)
					nftAsset.unit.slice(0, 56), // policy
					nftAsset.unit.slice(56) // name
				]);

				// Build redeemer
				const redeemer = conStr0([days]);

				// Build transaction with proper time validity
				const tx = new Transaction({ initiator: wallet, parameters: blockfrostProvider });
				
				// Set validity interval - this is key for Aiken scripts
				const slot = await blockfrostProvider.fetchProtocolParameters().then(p => p.slot);
				tx.setTimeToStart(slot);
				tx.setTimeToExpire(slot + 600); // 10 minutes
				
				// Add required signers
				tx.setRequiredSigners([walletAddress]);
				
				// Redeem from script
				tx.redeemValue(
					scriptCBOR,
					utxo,
					{
						datum: utxo.output.plutusData,
						redeemer: { data: redeemer }
					}
				)
				.sendLovelace(lenderAddress, (daily_fee * days).toString())
				.sendAssets(
					{
						address: scriptAddress,
						datum: { value: updatedDatum }
					},
					[{ unit: nftAsset.unit, quantity: '1' }]
				);

				const unsignedTx = await tx.build();
				const signedTx = await wallet.signTx(unsignedTx);
				const txHash = await wallet.submitTx(signedTx);

				document.getElementById('txStatus').textContent = `Rented! Tx: ${txHash}`;
				setTimeout(populateRentalPicker, 3000);
			} catch (error) {
				console.error('=== RENT ERROR ===');
				console.error('Full error:', error);
				document.getElementById('txStatus').textContent = `Error: ${error.message}`;
			}
		});
	</script>
</body>
</html>