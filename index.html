<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Cardano NFT Book Rental DApp</title>
</head>
<body>
	<h1>Rent a Book NFT on Cardano Preprod</h1>
	<p>Connect your Eternl wallet on Preprod network.</p>
	
	<button id="connectWallet">Connect Eternl Wallet</button>
	<p id="walletStatus"></p>

	<h2>List Rental Offer</h2>
	<label for="daily_fee">Daily Fee (lovelace):</label>
	<input type="number" id="daily_fee" min="1000000" value="1000000">
	
	<label for="min_days">Min Days:</label>
	<input type="number" id="min_days" min="1" value="1">
	
	<label for="max_days">Max Days:</label>
	<input type="number" id="max_days" min="1" value="30">
	
	<label for="auto_relist">Auto Relist:</label>
	<input type="checkbox" id="auto_relist" checked>
	
	<label for="nft_picker">Select NFT to List:</label>
	<select id="nft_picker">
		<option value="">--Select an NFT--</option>
	</select>
	
	<button id="listButton" disabled>List Rental</button>
	<p id="listStatus"></p>

	<h2>Rent Book</h2>
	<label for="rental_picker">Select Rental to Rent:</label>
	<select id="rental_picker">
		<option value="">--Select a Rental--</option>
	</select>
	
	<label for="days">Days to Rent:</label>
	<input type="number" id="days" min="1" value="1">
	
	<button id="rentButton" disabled>Rent Book</button>
	<p id="txStatus"></p>

	<script type="module">
		import { Blockfrost, Lucid, Data, Constr } from "https://unpkg.com/lucid-cardano@0.10.7/web/mod.js";

		const scriptAddress = 'addr_test1wzvnyvs6at8sk56yvca400cjchzeeh3h5ednq5grczv2jag04uv5c';
		const scriptHash = '9932321aeacf0b5344663b57bf12c5c59cde37a65b305103c098a975';
		const blockfrostKey = 'preprod5njBajXTux1u0d7vJCH9kOgsvPCDIe6W';
		
		let lucid;

		async function initLucid() {
			lucid = await Lucid.new(
				new Blockfrost('https://cardano-preprod.blockfrost.io/api/v0', blockfrostKey),
				'Preprod'
			);
		}

		// Function to hex-decode asset name to readable string if possible
		function hexToString(hex) {
			try {
				let str = '';
				for (let i = 0; i < hex.length; i += 2) {
					str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
				}
				return str;
			} catch (e) {
				return hex; // Fallback to hex if not decodable
			}
		}

		// Populate NFT picker from wallet assets
		async function populateNftPicker() {
			const nftPicker = document.getElementById('nft_picker');
			nftPicker.innerHTML = '<option value="">--Select an NFT--</option>';
			
			const utxos = await lucid.wallet.getUtxos();
			const assets = {};
			utxos.forEach(utxo => {
				Object.entries(utxo.assets).forEach(([asset, qty]) => {
					if (asset !== 'lovelace' && qty > 0n) {
						if (!assets[asset]) assets[asset] = 0n;
						assets[asset] += qty;
					}
				});
			});

			Object.keys(assets).forEach(asset => {
				if (assets[asset] === 1n) { // Assume NFTs have quantity 1
					const policy = asset.slice(0, 56);
					const nameHex = asset.slice(56);
					const name = hexToString(nameHex);
					const option = document.createElement('option');
					option.value = `${policy}|${nameHex}`;
					option.textContent = `Policy: ${policy.slice(0,10)}... Name: ${name} (Qty: 1)`;
					nftPicker.appendChild(option);
				}
			});
		}

		// Populate rental picker from script UTxOs
		async function populateRentalPicker() {
			try {
				const rentalPicker = document.getElementById('rental_picker');
				rentalPicker.innerHTML = '<option value="">--Select a Rental--</option>';
				
				const utxos = await lucid.utxosAt(scriptAddress);
				console.log(`Found ${utxos.length} UTxOs at script address`);
				
				for (const utxo of utxos) {
					if (Object.keys(utxo.assets).some(asset => asset !== 'lovelace')) {
						if (!utxo.datum) {
							console.log('Skipping UTxO without inline datum');
							continue;
						}
						try {
							const rawDatum = Data.from(utxo.datum);
							console.log('Raw datum structure:', rawDatum);
							
							// Check if it's an array/list structure
							if (!Array.isArray(rawDatum)) {
								console.log('Skipping non-array datum');
								continue;
							}
							
							const datum = rawDatum;
							
							// Validate datum has expected structure (9 elements)
							if (datum.length !== 9) {
								console.log(`Skipping datum with wrong length: ${datum.length}`);
								continue;
							}
							
							// Check if renter_pkh (index 5) indicates not rented
							const renter_pkh = datum[5];
							if (renter_pkh && renter_pkh.index === 1) { // Only show available (not rented)
								const nft_name = datum[8] && typeof datum[8] === 'string' ? hexToString(datum[8]) : 'Unknown';
								const daily_fee = datum[1] && typeof datum[1] === 'bigint' ? Number(datum[1]) : 0;
								const min_days = datum[2] && typeof datum[2] === 'bigint' ? Number(datum[2]) : 0;
								const max_days = datum[3] && typeof datum[3] === 'bigint' ? Number(datum[3]) : 0;
								
								const option = document.createElement('option');
								option.value = utxo.txHash + '#' + utxo.outputIndex;
								option.textContent = `NFT: ${nft_name} | Fee: ${daily_fee / 1000000} ADA/day | Min/Max: ${min_days}-${max_days} days`;
								rentalPicker.appendChild(option);
							} else {
								console.log('Skipping rented NFT');
							}
						} catch (e) {
							console.error('Error parsing datum:', e);
							continue;
						}
					}
				}
			} catch (e) {
				console.error('Error in populateRentalPicker:', e);
			}
		}

		document.getElementById('connectWallet').addEventListener('click', async () => {
			await initLucid();
			if (window.cardano && window.cardano.eternl) {
				lucid.selectWallet(await window.cardano.eternl.enable());
				document.getElementById('walletStatus').textContent = 'Wallet connected!';
				document.getElementById('listButton').disabled = false;
				document.getElementById('rentButton').disabled = false;
				await populateNftPicker();
				await populateRentalPicker();
			} else {
				document.getElementById('walletStatus').textContent = 'Eternl wallet not found.';
			}
		});

		document.getElementById('listButton').addEventListener('click', async () => {
			try {
				const daily_fee = parseInt(document.getElementById('daily_fee').value);
				const min_days = parseInt(document.getElementById('min_days').value);
				const max_days = parseInt(document.getElementById('max_days').value);
				const auto_relist = document.getElementById('auto_relist').checked;
				const selectedNft = document.getElementById('nft_picker').value;

				if (!selectedNft || daily_fee <= 0 || min_days <= 0 || max_days <= 0 || min_days > max_days) throw new Error('Invalid listing inputs');
				
				const [nft_policy, nft_name] = selectedNft.split('|');

				const lenderAddress = await lucid.wallet.address();
				const lenderPkh = lucid.utils.getAddressDetails(lenderAddress).paymentCredential.hash;

				// Create datum as array directly
				const datum = Data.to([
					lenderPkh,
					BigInt(daily_fee),
					BigInt(min_days),
					BigInt(max_days),
					{ constructor: auto_relist ? 1 : 0, fields: [] },
					{ constructor: 1, fields: [] },
					{ constructor: 1, fields: [] },
					nft_policy,
					nft_name
				]);

				const assets = {
					[`${nft_policy}${nft_name}`]: 1n,
					lovelace: 2000000n // ~2 ADA min, Lucid will add more if required
				};

				const tx = await lucid.newTx()
					.payToContract(scriptAddress, { inline: datum }, assets)
					.complete();

				const signedTx = await tx.sign().complete();
				const txHash = await signedTx.submit();

				document.getElementById('listStatus').textContent = `Rental listed! Tx: ${txHash}`;
				await populateRentalPicker(); // Refresh rentals after listing
			} catch (error) {
				document.getElementById('listStatus').textContent = `Error: ${error.message}`;
			}
		});

		document.getElementById('rentButton').addEventListener('click', async () => {
			console.log('=== RENT BUTTON CLICKED ===');
			try {
				console.log('Starting rent process...');
				const days = parseInt(document.getElementById('days').value);
				const selectedRental = document.getElementById('rental_picker').value;
				console.log('Days:', days, 'Selected rental:', selectedRental);
				
				if (!selectedRental || days <= 0) throw new Error('Invalid rental selection or days');

				const [txHash, outputIndex] = selectedRental.split('#');
				console.log('Looking for UTXO:', txHash, outputIndex);
				
				const utxos = await lucid.utxosAt(scriptAddress);
				console.log('All UTXOs at script address:', utxos.length);
				
				const escrowUtxo = utxos.find(utxo => utxo.txHash === txHash && utxo.outputIndex === parseInt(outputIndex));
				if (!escrowUtxo) throw new Error('Selected escrow UTxO not found');
				console.log('Found escrow UTXO');

				if (!escrowUtxo.datum) throw new Error('Escrow UTxO has no inline datum');

				// Read datum from UTxO
				console.log('Reading datum...');
				const rawDatum = Data.from(escrowUtxo.datum);
				if (!Array.isArray(rawDatum)) throw new Error('Invalid datum format: not an array');
				const datum = rawDatum;
				console.log('Datum read successfully');

				console.log('Datum validation...');
				console.log('Days range:', datum[2], '-', datum[3], 'Requested days:', days);
				if (days < datum[2] || days > datum[3]) throw new Error('Days out of range');
				
				console.log('Renter status:', datum[5]);
				if (datum[5].index !== 1) throw new Error('Already rented');

				// Get renter PKH
				const renterAddress = await lucid.wallet.address();
				const renterPkh = lucid.utils.getAddressDetails(renterAddress).paymentCredential.hash;
				console.log('Renter PKH:', renterPkh);

				// Calculate deadline (current time + days * ms per day)
				console.log('Fetching current time...');
				const latestBlockResponse = await fetch('https://cardano-preprod.blockfrost.io/api/v0/blocks/latest', {
					headers: { 'project_id': blockfrostKey }
				});
				const latestBlock = await latestBlockResponse.json();
				const currentTime = latestBlock.time * 1000;
				const deadline = currentTime + (days * 86400000);
				console.log('Deadline calculated:', deadline);

				console.log('Creating updated datum...');
				
				// Updated datum - use the same format as listButton (which works)
				let updatedDatum;
				try {
					updatedDatum = Data.to([
						datum[0], // lender_pkh - keep as is (string)
						datum[1], // daily_fee - keep as is (bigint)
						datum[2], // min_days - keep as is (bigint) 
						datum[3], // max_days - keep as is (bigint)
						{ constructor: datum[4].index, fields: [] }, // auto_relist
						{ constructor: 0, fields: [renterPkh] }, // renter_pkh Some variant
						{ constructor: 0, fields: [BigInt(Math.floor(deadline))] }, // deadline Some variant
						datum[7], // nft_policy - keep as is (string)
						datum[8]  // nft_name - keep as is (string)
					]);
					console.log('Updated datum created successfully');
				} catch (e) {
					console.error('Error creating updated datum:', e);
					console.error('Datum values:', {
						lender_pkh: datum[0],
						daily_fee: datum[1],
						min_days: datum[2],
						max_days: datum[3],
						auto_relist: datum[4],
						renter_pkh: renterPkh,
						deadline: deadline,
						nft_policy: datum[7],
						nft_name: datum[8]
					});
					throw e;
				}

				// Redeemer for Rent
				console.log('Creating redeemer...');
				let redeemer;
				try {
					redeemer = Data.to({
						constructor: 0,
						fields: [ BigInt(days) ]
					});
					console.log('Redeemer created successfully');
				} catch (e) {
					console.error('Error creating redeemer:', e);
					throw e;
				}

				// Payment to lender  
				const fee = datum[1] * BigInt(days);
				const lenderAddress = lucid.utils.credentialToAddress({ type: 'Key', hash: datum[0] }, lucid.network);

				console.log('Building transaction...');
				console.log('Lender address:', lenderAddress);
				console.log('Fee:', fee);
				console.log('Script hash:', scriptHash);

				// Build tx
				const tx = await lucid.newTx()
					.collectFrom([escrowUtxo], redeemer)
					.attachSpendingValidator({ type: 'PlutusV3', script: scriptHash })
					.payToAddress(lenderAddress, { lovelace: fee })
					.payToContract(scriptAddress, { inline: updatedDatum }, escrowUtxo.assets) // Preserve NFT + ADA
					.complete();

				console.log('Transaction built, signing...');
				const signedTx = await tx.sign().complete();
				const txHashResult = await signedTx.submit();

				document.getElementById('txStatus').textContent = `Rental successful! Tx: ${txHashResult}`;
				await populateRentalPicker(); // Refresh rentals after renting
			} catch (error) {
				console.error('=== RENT ERROR ===');
				console.error('Full error:', error);
				console.error('Error stack:', error.stack);
				document.getElementById('txStatus').textContent = `Error: ${error.message}`;
			}
		});
	</script>
</body>
</html>